*** Begin Patch
*** Update File: container/nsforest/context/src/nsforest_cli/violinplot.py
@@
-from __future__ import annotations
-
-from pathlib import Path
-from typing import Dict, List, Optional, Sequence
-
-import scanpy as sc
-import matplotlib.pyplot as plt
+from __future__ import annotations
+
+from pathlib import Path
+from typing import Dict, List, Optional, Sequence
+
+import scanpy as sc
+import matplotlib.pyplot as plt
@@
 def violinplot_run(
     h5ad_in: Path,
     results_csv: Path,
     label_key: str,
     *,
@@
 ):
     """Stacked violin via nsforest (tutorial-style) with dendrogram order.
 
     - No directories created; we save exactly the filenames passed.
-    - If `log1p=True`, we log-transform a plotting copy and **force Scanpy to use X**
-    by clearing `.raw` to avoid unintentional use of raw counts.
+    - If `log1p=True`, we log-transform a plotting copy **on the subset of genes
+      actually plotted**, and force plotting to use `X` (not `.raw`).
     """
@@
-    # Build markers_dict
+    # Build markers_dict
     def _split(val: str) -> list[str]:
         if not isinstance(val, str):
             return []
         s = val.strip()
         if s.startswith("[") and s.endswith("]"):
@@
-    markers_dict: Dict[str, List[str]] = {
-        row[cluster_col]: _split(row[markers_col]) for _, row in df.iterrows() if row[cluster_col] in dendrogram
-    }
+    markers_dict: Dict[str, List[str]] = {
+        row[cluster_col]: _split(row[markers_col]) for _, row in df.iterrows() if row[cluster_col] in dendrogram
+    }
+
+    # Determine union of genes to plot in shown order (cluster order respected)
+    union_order: List[str] = []
+    seen = set()
+    for cl in dendrogram:
+        for g in markers_dict.get(cl, []):
+            if g not in seen:
+                seen.add(g)
+                union_order.append(g)
+    if not union_order:
+        raise ValueError("No marker genes found to plot (empty union).")
+
+    # Restrict to genes present in this AnnData
+    present = [g for g in union_order if g in adata.var_names]
+    if not present:
+        raise ValueError("None of the requested marker genes are present in adata.var_names.")
@@
-    # Prepare plotting copy and apply log1p if requested; ensure raw is not used
-    ad_for_plot = adata.copy()
-    ad_for_plot.raw = None  # force downstream plotting to use X, not .raw
+    # Prepare plotting copy *sliced to present genes*; ensure .raw not used
+    ad_for_plot = adata[:, present].copy()
+    ad_for_plot.raw = None  # force downstream plotting to use X, not .raw
     if log1p:
         X = ad_for_plot.X
         if sparse.issparse(X):
             ad_for_plot.X = sparse.csr_matrix(np.log1p(X.toarray()))
         else:
             ad_for_plot.X = np.log1p(X)
@@
-    ax = ns.pl.stackedviolin(
+    ax = ns.pl.stackedviolin(
         ad_for_plot,
         markers_dict,
         label_key,
         dendrogram=dendrogram,
         save=False,
         output_folder=".",
         outputfilename_suffix=".",
     )
*** End Patch

*** Begin Patch
*** Update File: container/nsforest/context/src/nsforest_cli/dotplot.py
@@
-from __future__ import annotations
-
-from pathlib import Path
-from typing import Dict, List, Optional, Sequence
-
-import scanpy as sc
-import matplotlib.pyplot as plt
+from __future__ import annotations
+
+from pathlib import Path
+from typing import Dict, List, Optional, Sequence
+
+import scanpy as sc
+import matplotlib.pyplot as plt
@@
 def dotplot_run(
     h5ad_in: Path,
     results_csv: Path,
     *,
     label_key: str,
@@
 ):
     """Matrix/dot plot using nsforest's plotting API, with dendrogram order.
 
     - No dir creation; save exactly the filenames requested.
-    - Honors `log1p` by transforming a copy of AnnData before plotting.
+    - Honors `log1p` by transforming a plotting copy **on the subset of genes
+      actually plotted**, and forces plotting to use `X` (not `.raw`).
     - Supports optional dendrogram subsetting via `leaf_indices` / `leaf_range`
       and/or explicit `clusters` list (intersection applied).
     """
@@
-    # Prepare plotting copy and apply log1p if requested; ensure raw is not used
-    ad_for_plot = adata.copy()
-    ad_for_plot.raw = None
-    if log1p:
-        X = ad_for_plot.X
-        if sparse.issparse(X):
-            ad_for_plot.X = sparse.csr_matrix(np.log1p(X.toarray()))
-        else:
-            ad_for_plot.X = np.log1p(X)
+    # Determine union of genes to plot in shown order
+    union_order: List[str] = []
+    seen = set()
+    for cl in dendrogram:
+        for g in markers_dict.get(cl, []):
+            if g not in seen:
+                seen.add(g)
+                union_order.append(g)
+    if not union_order:
+        raise ValueError("No marker genes found to plot (empty union).")
+
+    present = [g for g in union_order if g in adata.var_names]
+    if not present:
+        raise ValueError("None of the requested marker genes are present in adata.var_names.")
+
+    # Prepare plotting copy (slice to present genes) and apply log1p; ensure raw is not used
+    ad_for_plot = adata[:, present].copy()
+    ad_for_plot.raw = None
+    if log1p:
+        X = ad_for_plot.X
+        if sparse.issparse(X):
+            ad_for_plot.X = sparse.csr_matrix(np.log1p(X.toarray()))
+        else:
+            ad_for_plot.X = np.log1p(X)
*** End Patch

